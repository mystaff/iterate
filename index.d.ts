declare const _exports: {
    /**
      Short-circuit to package import namespace.
      @example
      //
      const { _ } = require('@mystaff/iterate');
      // is the same as:
      const _ = require('@mystaff/iterate');
    */
    _: {
        Debug: {
            originalPrepareStackTrace: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            prepareStackTraceRelative: typeof import("./debug/stack-trace").prepareStackTraceRelative;
            setRelativeStackTrace: typeof import("./debug/stack-trace").setRelativeStackTrace;
            resetDefaultStackTrace: typeof import("./debug/stack-trace").resetDefaultStackTrace;
            createDebuggerCommandsClosure: (_: any) => void;
            debug(scopeCallback: Function, options?: {
                condition?: Function;
                resultCallback?: Function;
                callStackDepth?: Function;
            }): Function;
        };
        originalPrepareStackTrace: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
        prepareStackTraceRelative: typeof import("./debug/stack-trace").prepareStackTraceRelative;
        setRelativeStackTrace: typeof import("./debug/stack-trace").setRelativeStackTrace;
        resetDefaultStackTrace: typeof import("./debug/stack-trace").resetDefaultStackTrace;
        createDebuggerCommandsClosure: (_: any) => void;
        debug(scopeCallback: Function, options?: {
            condition?: Function;
            resultCallback?: Function;
            callStackDepth?: Function;
        }): Function;
        Iterate: typeof Iterate;
        voidFunction: () => void;
        Function: Function;
        voidAsyncFunction: () => Promise<void>;
        AsyncFunction: Function;
        voidIterator: Iterator<any, any, any>;
        voidGeneratorFunction: () => Generator<never, void, unknown>;
        GeneratorFunction: Function;
        voidAsyncIterator: AsyncIterator<any, any, any>;
        voidAsyncGeneratorFunction: () => AsyncGenerator<never, void, unknown>;
        exhaustedIteratorResult: IteratorResult;
        AsyncGeneratorFunction: Function;
        chainGeneratorFunctionWrapper: (genFunc: Function) => Function;
        generationGeneratorFunctionWrapper: (genFunc: Function, Class: constructor) => Function;
        wrapProperties(object: any, types: Set<constructor>, wrapper: (arg0: Function) => any, ...args: any[]): void;
        unwindObjectPrototypes(object: any, to?: any): any;
        flattenObjectPrototypes(object: any, prototype?: any): void;
        fatal(error: any): never;
        curry: (func: Function | object | string | number | symbol, context?: Function | object | null, ...args?: any[]) => Function;
        curryFunction: (func: Function) => Function;
        curryMethod: (func: Function | string | number | symbol, context: object) => Function;
        curryContext: (func: Function) => Function;
        curryMethods(object: object, methodNames?: Iterable<string | symbol> | object | null, curried?: object): object;
        objectPropertyNames(object: object, typeSet?: Set<string> | null, prototypeSet?: Set<object> | null, depth?: number): any;
        functionTypes: Set<string>;
        curryInstance(object: object, curried?: object): object;
        delay(milliseconds: number, result: any): Promise<any>;
        arrayFromAsync(iterable: AsyncIterable<any>): Array<any>;
        getIterable: (iterator: Iterator<any, any, any>) => Iterable<any>;
        getAsyncIterable: (asyncIterator: AsyncIterator<any, any, any>) => AsyncIterable<any>;
        Window: typeof import("./logic/window");
        WindowIterator: typeof import("./logic/window-iterator");
        echo: (value: any) => any;
        echoAsync: (value: any) => any;
        valueFn: (value: any) => MappingFunction;
        isNullish: (value: any) => boolean;
        isNotNullish: (value: any) => boolean;
        not: (value: any) => boolean;
        inOf: (object: object) => MappingFunction;
        in: (key: any) => MappingFunction;
        hasOwnOf: (object: object) => MappingFunction;
        hasOwn: (key: any) => MappingFunction;
        propertyOf: (object: object) => MappingFunction;
        property: (key: any) => MappingFunction;
        getOf: (map: (Map<any, any> | WeakMap<any, any>)) => MappingFunction;
        get: (key: any) => MappingFunction;
        atOf: (array: any[]) => MappingFunction;
        at: (index: any) => MappingFunction;
        hasOf: (mapOrSet: (Map<any, any> | Set<any> | WeakMap<any, any> | WeakSet<any>)) => MappingFunction;
        has: (item: any) => MappingFunction;
        pigOf(collection: (any[] | Map<any, any> | WeakMap<any, any> | Set<any> | WeakSet<any> | object)): MappingFunction;
        pig(key: any): MappingFunction;
        times(count: number): MappingFunction;
        trueTimes(count: number): MappingFunction;
        counter(start: number, step?: number): MappingFunction;
        trueCounter(start: number, step?: number): MappingFunction;
        lag(steps: number, { window, defaultValue, map }?: object): MappingFunction;
        window(count: number, { window, defaultValue, map }?: object): MappingFunction;
        stretch(count: number): MappingFunction;
        ifNull: (mapper: MappingFunction, ...args: any[]) => MappingFunction;
        nullDefault: (defaultValue: any) => MappingFunction;
        if: (conditionPredicator: PredicatorPipeline, truthyMapper: MapperPipeline, falsyMapper: MapperPipeline) => MappingFunction;
        mappingByParam: (paramTypeMap: any) => (parameter: any) => any;
        mapperParam(parameter: MapperParam): MappingFunction;
        predicatorParam(parameter: PredicatorParam): MappingFunction;
        pipelineMapping: (functions: MappingFunction[], optimize?: boolean) => MappingFunction;
        mapInPlace(object: any | any[], mapperFunction: any, ...args: any[]): any | any[];
        mapper: (functions: MapperPipeline, optimize?: boolean) => MapperFunction;
        predicator: (functions: PredicatorPipeline, optimize?: boolean) => PredicatorFunction;
    };
    Debug: {
        originalPrepareStackTrace: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
        prepareStackTraceRelative: typeof import("./debug/stack-trace").prepareStackTraceRelative;
        setRelativeStackTrace: typeof import("./debug/stack-trace").setRelativeStackTrace;
        resetDefaultStackTrace: typeof import("./debug/stack-trace").resetDefaultStackTrace;
        createDebuggerCommandsClosure: (_: any) => void;
        debug(scopeCallback: Function, options?: {
            condition?: Function;
            resultCallback?: Function;
            callStackDepth?: Function;
        }): Function;
    };
    originalPrepareStackTrace: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
    prepareStackTraceRelative: typeof import("./debug/stack-trace").prepareStackTraceRelative;
    setRelativeStackTrace: typeof import("./debug/stack-trace").setRelativeStackTrace;
    resetDefaultStackTrace: typeof import("./debug/stack-trace").resetDefaultStackTrace;
    createDebuggerCommandsClosure: (_: any) => void;
    debug(scopeCallback: Function, options?: {
        condition?: Function;
        resultCallback?: Function;
        callStackDepth?: Function;
    }): Function;
    Iterate: typeof Iterate;
    voidFunction: () => void;
    Function: Function;
    voidAsyncFunction: () => Promise<void>;
    AsyncFunction: Function;
    voidIterator: Iterator<any, any, any>;
    voidGeneratorFunction: () => Generator<never, void, unknown>;
    GeneratorFunction: Function;
    voidAsyncIterator: AsyncIterator<any, any, any>;
    voidAsyncGeneratorFunction: () => AsyncGenerator<never, void, unknown>;
    exhaustedIteratorResult: IteratorResult;
    AsyncGeneratorFunction: Function;
    chainGeneratorFunctionWrapper: (genFunc: Function) => Function;
    generationGeneratorFunctionWrapper: (genFunc: Function, Class: constructor) => Function;
    wrapProperties(object: any, types: Set<constructor>, wrapper: (arg0: Function) => any, ...args: any[]): void;
    unwindObjectPrototypes(object: any, to?: any): any;
    flattenObjectPrototypes(object: any, prototype?: any): void;
    fatal(error: any): never;
    curry: (func: Function | object | string | number | symbol, context?: Function | object | null, ...args?: any[]) => Function;
    curryFunction: (func: Function) => Function;
    curryMethod: (func: Function | string | number | symbol, context: object) => Function;
    curryContext: (func: Function) => Function;
    curryMethods(object: object, methodNames?: Iterable<string | symbol> | object | null, curried?: object): object;
    objectPropertyNames(object: object, typeSet?: Set<string> | null, prototypeSet?: Set<object> | null, depth?: number): any;
    functionTypes: Set<string>;
    curryInstance(object: object, curried?: object): object;
    delay(milliseconds: number, result: any): Promise<any>;
    arrayFromAsync(iterable: AsyncIterable<any>): Array<any>;
    getIterable: (iterator: Iterator<any, any, any>) => Iterable<any>;
    getAsyncIterable: (asyncIterator: AsyncIterator<any, any, any>) => AsyncIterable<any>;
    Window: typeof import("./logic/window");
    WindowIterator: typeof import("./logic/window-iterator");
    echo: (value: any) => any;
    echoAsync: (value: any) => any;
    valueFn: (value: any) => MappingFunction;
    isNullish: (value: any) => boolean;
    isNotNullish: (value: any) => boolean;
    not: (value: any) => boolean;
    inOf: (object: object) => MappingFunction;
    in: (key: any) => MappingFunction;
    hasOwnOf: (object: object) => MappingFunction;
    hasOwn: (key: any) => MappingFunction;
    propertyOf: (object: object) => MappingFunction;
    property: (key: any) => MappingFunction;
    getOf: (map: (Map<any, any> | WeakMap<any, any>)) => MappingFunction;
    get: (key: any) => MappingFunction;
    atOf: (array: any[]) => MappingFunction;
    at: (index: any) => MappingFunction;
    hasOf: (mapOrSet: (Map<any, any> | Set<any> | WeakMap<any, any> | WeakSet<any>)) => MappingFunction;
    has: (item: any) => MappingFunction;
    pigOf(collection: (any[] | Map<any, any> | WeakMap<any, any> | Set<any> | WeakSet<any> | object)): MappingFunction;
    pig(key: any): MappingFunction;
    times(count: number): MappingFunction;
    trueTimes(count: number): MappingFunction;
    counter(start: number, step?: number): MappingFunction;
    trueCounter(start: number, step?: number): MappingFunction;
    lag(steps: number, { window, defaultValue, map }?: object): MappingFunction;
    window(count: number, { window, defaultValue, map }?: object): MappingFunction;
    stretch(count: number): MappingFunction;
    ifNull: (mapper: MappingFunction, ...args: any[]) => MappingFunction;
    nullDefault: (defaultValue: any) => MappingFunction;
    if: (conditionPredicator: PredicatorPipeline, truthyMapper: MapperPipeline, falsyMapper: MapperPipeline) => MappingFunction;
    mappingByParam: (paramTypeMap: any) => (parameter: any) => any;
    mapperParam(parameter: MapperParam): MappingFunction;
    predicatorParam(parameter: PredicatorParam): MappingFunction;
    pipelineMapping: (functions: MappingFunction[], optimize?: boolean) => MappingFunction;
    mapInPlace(object: any | any[], mapperFunction: any, ...args: any[]): any | any[];
    mapper: (functions: MapperPipeline, optimize?: boolean) => MapperFunction;
    predicator: (functions: PredicatorPipeline, optimize?: boolean) => PredicatorFunction;
};
export = _exports;
import Iterate = require("./iterate");
